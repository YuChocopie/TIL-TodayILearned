# 단위 테스트 (Unit test)

가장 작은 단위의 테스트이며, 모든 테스트의 시작점

### Why?

단위 테스트, 혹은 여느 테스트 코드를 작성하는 일은 상당한 투자와 비용이 드는 작업이다.

하지만 테스트는 프로덕 코드의 결함을 최소화하고 리팩토링으로 프로덕 시스템을 깔끔하게 유지시켜준다.

### 개발시간만 더 늘어나는 거 아냐?

단위 테스트는 오히려 개발 시간을 단축시켜준다. 
 main 메서드 안에 표준출력 등을 이용하여 수동으로 검증하는 것은 시간 소모적인 절차고 위험의 리스크가 증가할 수 있다.

### How? 

> 그래서 단위테스트를 하는 방법이 뭔데?

여러가지 방법이 있지만 JAVA에서는 JUnit을 사용한다

![junit](/Users/kim-yujeong/work/TIL-TodayILearned/image/junit.png)

자바만 단위 테스팅 프레임 워크인 JUnit만 있는게 아니다. 
다른 언어도 단위 테스트를 위한 프레임워크가 존재하며 보통 이름을 xUnit이라 칭함

| xUnit이름 | 해당 언어 | 관련 사이트                               |
| --------- | --------- | ----------------------------------------- |
| CUnit     | C         | http://cunit.sourceforge.net/             |
| CppUnit   | C++       | https://sourceforge.net/projects/cppunit/ |
| PHPUnit   | PHp       | https://phpunit.de/                       |
| PyUnit    | Python    | http://pyunit.sourceforge.net/            |
| JUnit     | Java      | http://junit.org/                         |



#### JUnit Annotation

@Test : 해당 Method는 Test대상 메소드임을 의미한다.

![junit_ex1](/Users/kim-yujeong/work/TIL-TodayILearned/image/junit_ex1.png)



@BeforeClass : 해당 테스트가 시작 전에 딱 한 번씩만 수행되도록 지정한다.

@AfterClass : 해당 테스트가 끝나고 딱 한 번씩만 수행되도록 지정한다.

![junit_ex2](/Users/kim-yujeong/work/TIL-TodayILearned/image/junit_ex2.png)



@Before : 해당 테스트가 진행이 시작되기 전에 작업할 내용을 호출한다.

@After : 해당 테스트가 진행이 끝난 후에 작업할 내용을 호출한다.

@Ignore : 만약 테스트에서 제외하고 싶은 메서드가 있을 경우 호출한다.

![junit_ex3](/Users/kim-yujeong/work/TIL-TodayILearned/image/junit_ex3.png)



##### Flow 

![junit_ex4](/Users/kim-yujeong/work/TIL-TodayILearned/image/junit_ex4.png)

| 예시1                                                        | 예시2                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| @BeforeClass<br/>@Before<br/>@Test(some1)<br/>@After<br/>@Before<br/>@Test(some2)<br/>@After<br/>@AfterClass | @BeforeClass<br/>@Before<br/>@Test(some2)<br/>@After<br/>@Before<br/>@Test(some1)<br/>@After<br/>@AfterClass |

> @Test는 어떠한 순서로 실행될지 알 수 없다. 
> 물론 
> @FixMethodOrder(MethodSorters.NAME_ASCENDING)와 같은 애너테이션을 테스트 클래스에 붙여 메서드 이름의 내림차순,오름차순으로 순서를 지정할 수는 있다.



### FIRST 속성

**단위** **테스트를** **작성하는데** **있어서** **FIRST** **속성을** **지킨다면** **더** **좋은** **단위테스트를** **작성할** **수** **있다**

- Fast (빠른) : 유닛테스트는 빨라야한다
- Isolated (고립된) : 다른 테스트에 종속적인 테스트는 절대로 작성하지 않는다.
- Repeatable (반복 가능한) - 테스트는 실행할 때마다 같은 결과를 만들어야 한다. 즉 어떤 상황에서는 성공, 어떤 상황에서는 실패하는 테스트코드를 만들지 말아야한다. 현재시간을 다루는 것과 같게 반복한 테스트가 어렵다면 **목 객체**를 이용해 분리시킬 수 있다.
- Self-validating (스스로 검증 가능한): 테스트는 기대하는 결과가 무엇인지 단언할 수 있어야 한다.
- Timely (적시의): 유닛 테스트는 프로덕션 코드가 테스트를 성공하기 직전에 구성되어야 한다.



### 목(Mock) 객체

#### 목객체를 쓰는 경우

목(Mock) 객체를 사용하여 테스트하기 힘든, 혹은 외부환경과 의존성을 끊는 테스트를 하기 위한 방법이 있다.직접 API를 호출할 필요가 없는 테스트지만 특정 API를 호출하고 있는 로직에서 사용하는 것이 Mock 객체이다.

#### 목객체의 장점

##### api 를 사용해 데이터를 받아오는지 Test하는 경우 두가지 방법이 있다.

1. api에서 올바른 값을 받아 오는가 
2. **우리가 개발한대로 로직이 정상동작 하는가**

2의 경우 외부환경을 신경쓸 필요가 없이 비지니스로직의 성공유무를 테스트할 수 있다.

외부환경에 따라 테스트가 빨리 끝날 수도 있지만, 외부환경이 갑자기 트래픽이 몰리는 시간이라면 테스트가 느리게 끝날 수도 있다. 하지만 목(Mock)객체를 사용한다면 직접 API를 호출하여 결과를 받아오는 것이 아니기 때문에 빠른 테스트 시간을 유지할 수 있고 테스트의 복잡도를 낮춰준다.